begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"builtin.h"
end_include

begin_include
include|#
directive|include
file|"parse-options.h"
end_include

begin_include
include|#
directive|include
file|"lockfile.h"
end_include

begin_include
include|#
directive|include
file|"apply.h"
end_include

begin_decl_stmt
DECL|variable|apply_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|apply_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git apply [<options>] [<patch>...]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|lock_file
specifier|static
name|struct
name|lock_file
name|lock_file
decl_stmt|;
end_decl_stmt

begin_function
DECL|function|cmd_apply
name|int
name|cmd_apply
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|force_apply
init|=
literal|0
decl_stmt|;
name|int
name|options
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|apply_state
name|state
decl_stmt|;
name|struct
name|option
name|builtin_apply_options
index|[]
init|=
block|{
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"exclude"
block|,
operator|&
name|state
block|,
name|N_
argument_list|(
literal|"path"
argument_list|)
block|,
name|N_
argument_list|(
literal|"don't apply changes matching the given path"
argument_list|)
block|,
literal|0
block|,
name|apply_option_parse_exclude
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"include"
block|,
operator|&
name|state
block|,
name|N_
argument_list|(
literal|"path"
argument_list|)
block|,
name|N_
argument_list|(
literal|"apply changes matching the given path"
argument_list|)
block|,
literal|0
block|,
name|apply_option_parse_include
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'p'
block|,
name|NULL
block|,
operator|&
name|state
block|,
name|N_
argument_list|(
literal|"num"
argument_list|)
block|,
name|N_
argument_list|(
literal|"remove<num> leading slashes from traditional diff paths"
argument_list|)
block|,
literal|0
block|,
name|apply_option_parse_p
block|}
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"no-add"
argument_list|,
operator|&
name|state
operator|.
name|no_add
argument_list|,
name|N_
argument_list|(
literal|"ignore additions made by the patch"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"stat"
argument_list|,
operator|&
name|state
operator|.
name|diffstat
argument_list|,
name|N_
argument_list|(
literal|"instead of applying the patch, output diffstat for the input"
argument_list|)
argument_list|)
block|,
name|OPT_NOOP_NOARG
argument_list|(
literal|0
argument_list|,
literal|"allow-binary-replacement"
argument_list|)
block|,
name|OPT_NOOP_NOARG
argument_list|(
literal|0
argument_list|,
literal|"binary"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"numstat"
argument_list|,
operator|&
name|state
operator|.
name|numstat
argument_list|,
name|N_
argument_list|(
literal|"show number of added and deleted lines in decimal notation"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"summary"
argument_list|,
operator|&
name|state
operator|.
name|summary
argument_list|,
name|N_
argument_list|(
literal|"instead of applying the patch, output a summary for the input"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"check"
argument_list|,
operator|&
name|state
operator|.
name|check
argument_list|,
name|N_
argument_list|(
literal|"instead of applying the patch, see if the patch is applicable"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"index"
argument_list|,
operator|&
name|state
operator|.
name|check_index
argument_list|,
name|N_
argument_list|(
literal|"make sure the patch is applicable to the current index"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"cached"
argument_list|,
operator|&
name|state
operator|.
name|cached
argument_list|,
name|N_
argument_list|(
literal|"apply a patch without touching the working tree"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"unsafe-paths"
argument_list|,
operator|&
name|state
operator|.
name|unsafe_paths
argument_list|,
name|N_
argument_list|(
literal|"accept a patch that touches outside the working area"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"apply"
argument_list|,
operator|&
name|force_apply
argument_list|,
name|N_
argument_list|(
literal|"also apply the patch (use with --stat/--summary/--check)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'3'
argument_list|,
literal|"3way"
argument_list|,
operator|&
name|state
operator|.
name|threeway
argument_list|,
name|N_
argument_list|(
literal|"attempt three-way merge if a patch does not apply"
argument_list|)
argument_list|)
block|,
name|OPT_FILENAME
argument_list|(
literal|0
argument_list|,
literal|"build-fake-ancestor"
argument_list|,
operator|&
name|state
operator|.
name|fake_ancestor
argument_list|,
name|N_
argument_list|(
literal|"build a temporary index based on embedded index information"
argument_list|)
argument_list|)
block|,
comment|/* Think twice before adding "--nul" synonym to this */
name|OPT_SET_INT
argument_list|(
literal|'z'
argument_list|,
name|NULL
argument_list|,
operator|&
name|state
operator|.
name|line_termination
argument_list|,
name|N_
argument_list|(
literal|"paths are separated with NUL character"
argument_list|)
argument_list|,
literal|'\0'
argument_list|)
block|,
name|OPT_INTEGER
argument_list|(
literal|'C'
argument_list|,
name|NULL
argument_list|,
operator|&
name|state
operator|.
name|p_context
argument_list|,
name|N_
argument_list|(
literal|"ensure at least<n> lines of context match"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"whitespace"
block|,
operator|&
name|state
block|,
name|N_
argument_list|(
literal|"action"
argument_list|)
block|,
name|N_
argument_list|(
literal|"detect new or modified lines that have whitespace errors"
argument_list|)
block|,
literal|0
block|,
name|apply_option_parse_whitespace
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"ignore-space-change"
block|,
operator|&
name|state
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"ignore changes in whitespace when finding context"
argument_list|)
block|,
name|PARSE_OPT_NOARG
block|,
name|apply_option_parse_space_change
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"ignore-whitespace"
block|,
operator|&
name|state
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"ignore changes in whitespace when finding context"
argument_list|)
block|,
name|PARSE_OPT_NOARG
block|,
name|apply_option_parse_space_change
block|}
block|,
name|OPT_BOOL
argument_list|(
literal|'R'
argument_list|,
literal|"reverse"
argument_list|,
operator|&
name|state
operator|.
name|apply_in_reverse
argument_list|,
name|N_
argument_list|(
literal|"apply the patch in reverse"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"unidiff-zero"
argument_list|,
operator|&
name|state
operator|.
name|unidiff_zero
argument_list|,
name|N_
argument_list|(
literal|"don't expect at least one line of context"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"reject"
argument_list|,
operator|&
name|state
operator|.
name|apply_with_reject
argument_list|,
name|N_
argument_list|(
literal|"leave the rejected hunks in corresponding *.rej files"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"allow-overlap"
argument_list|,
operator|&
name|state
operator|.
name|allow_overlap
argument_list|,
name|N_
argument_list|(
literal|"allow overlapping hunks"
argument_list|)
argument_list|)
block|,
name|OPT__VERBOSE
argument_list|(
operator|&
name|state
operator|.
name|apply_verbosely
argument_list|,
name|N_
argument_list|(
literal|"be verbose"
argument_list|)
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"inaccurate-eof"
argument_list|,
operator|&
name|options
argument_list|,
name|N_
argument_list|(
literal|"tolerate incorrectly detected missing new-line at the end of file"
argument_list|)
argument_list|,
name|APPLY_OPT_INACCURATE_EOF
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"recount"
argument_list|,
operator|&
name|options
argument_list|,
name|N_
argument_list|(
literal|"do not trust the line counts in the hunk headers"
argument_list|)
argument_list|,
name|APPLY_OPT_RECOUNT
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"directory"
block|,
operator|&
name|state
block|,
name|N_
argument_list|(
literal|"root"
argument_list|)
block|,
name|N_
argument_list|(
literal|"prepend<root> to all filenames"
argument_list|)
block|,
literal|0
block|,
name|apply_option_parse_directory
block|}
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
if|if
condition|(
name|init_apply_state
argument_list|(
operator|&
name|state
argument_list|,
name|prefix
argument_list|,
operator|&
name|lock_file
argument_list|)
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|state
operator|.
name|prefix
argument_list|,
name|builtin_apply_options
argument_list|,
name|apply_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_apply_state
argument_list|(
operator|&
name|state
argument_list|,
name|force_apply
argument_list|)
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|ret
operator|=
name|apply_all_patches
argument_list|(
operator|&
name|state
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|clear_apply_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

