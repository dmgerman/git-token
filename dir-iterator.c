begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"iterator.h"
end_include

begin_include
include|#
directive|include
file|"dir-iterator.h"
end_include

begin_struct
DECL|struct|dir_iterator_level
struct|struct
name|dir_iterator_level
block|{
DECL|member|initialized
name|int
name|initialized
decl_stmt|;
DECL|member|dir
name|DIR
modifier|*
name|dir
decl_stmt|;
comment|/* 	 * The length of the directory part of path at this level 	 * (including a trailing '/'): 	 */
DECL|member|prefix_len
name|size_t
name|prefix_len
decl_stmt|;
comment|/* 	 * The last action that has been taken with the current entry 	 * (needed for directories, which have to be included in the 	 * iteration and also iterated into): 	 */
enum|enum
block|{
DECL|enumerator|DIR_STATE_ITER
name|DIR_STATE_ITER
block|,
DECL|enumerator|DIR_STATE_RECURSE
name|DIR_STATE_RECURSE
DECL|member|dir_state
block|}
name|dir_state
enum|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The full data structure used to manage the internal directory  * iteration state. It includes members that are not part of the  * public interface.  */
end_comment

begin_struct
DECL|struct|dir_iterator_int
struct|struct
name|dir_iterator_int
block|{
DECL|member|base
name|struct
name|dir_iterator
name|base
decl_stmt|;
comment|/* 	 * The number of levels currently on the stack. This is always 	 * at least 1, because when it becomes zero the iteration is 	 * ended and this struct is freed. 	 */
DECL|member|levels_nr
name|size_t
name|levels_nr
decl_stmt|;
comment|/* The number of levels that have been allocated on the stack */
DECL|member|levels_alloc
name|size_t
name|levels_alloc
decl_stmt|;
comment|/* 	 * A stack of levels. levels[0] is the uppermost directory 	 * that will be included in this iteration. 	 */
DECL|member|levels
name|struct
name|dir_iterator_level
modifier|*
name|levels
decl_stmt|;
block|}
struct|;
end_struct

begin_function
DECL|function|dir_iterator_advance
name|int
name|dir_iterator_advance
parameter_list|(
name|struct
name|dir_iterator
modifier|*
name|dir_iterator
parameter_list|)
block|{
name|struct
name|dir_iterator_int
modifier|*
name|iter
init|=
operator|(
expr|struct
name|dir_iterator_int
operator|*
operator|)
name|dir_iterator
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|dir_iterator_level
modifier|*
name|level
init|=
operator|&
name|iter
operator|->
name|levels
index|[
name|iter
operator|->
name|levels_nr
operator|-
literal|1
index|]
decl_stmt|;
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
if|if
condition|(
operator|!
name|level
operator|->
name|initialized
condition|)
block|{
comment|/* 			 * Note: dir_iterator_begin() ensures that 			 * path is not the empty string. 			 */
if|if
condition|(
operator|!
name|is_dir_sep
argument_list|(
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
index|[
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|iter
operator|->
name|base
operator|.
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|level
operator|->
name|prefix_len
operator|=
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|len
expr_stmt|;
name|level
operator|->
name|dir
operator|=
name|opendir
argument_list|(
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|level
operator|->
name|dir
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|warning
argument_list|(
literal|"error opening directory %s: %s"
argument_list|,
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Popping the level is handled below */
block|}
name|level
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|iter
operator|->
name|base
operator|.
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|level
operator|->
name|dir_state
operator|==
name|DIR_STATE_ITER
condition|)
block|{
comment|/* 				 * The directory was just iterated 				 * over; now prepare to iterate into 				 * it. 				 */
name|level
operator|->
name|dir_state
operator|=
name|DIR_STATE_RECURSE
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|iter
operator|->
name|levels
argument_list|,
name|iter
operator|->
name|levels_nr
operator|+
literal|1
argument_list|,
name|iter
operator|->
name|levels_alloc
argument_list|)
expr_stmt|;
name|level
operator|=
operator|&
name|iter
operator|->
name|levels
index|[
name|iter
operator|->
name|levels_nr
operator|++
index|]
expr_stmt|;
name|level
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* 				 * The directory has already been 				 * iterated over and iterated into; 				 * we're done with it. 				 */
block|}
block|}
if|if
condition|(
operator|!
name|level
operator|->
name|dir
condition|)
block|{
comment|/* 			 * This level is exhausted (or wasn't opened 			 * successfully); pop up a level. 			 */
if|if
condition|(
operator|--
name|iter
operator|->
name|levels_nr
operator|==
literal|0
condition|)
return|return
name|dir_iterator_abort
argument_list|(
name|dir_iterator
argument_list|)
return|;
continue|continue;
block|}
comment|/* 		 * Loop until we find an entry that we can give back 		 * to the caller: 		 */
while|while
condition|(
literal|1
condition|)
block|{
name|strbuf_setlen
argument_list|(
operator|&
name|iter
operator|->
name|base
operator|.
name|path
argument_list|,
name|level
operator|->
name|prefix_len
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|de
operator|=
name|readdir
argument_list|(
name|level
operator|->
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|de
condition|)
block|{
comment|/* This level is exhausted; pop up a level. */
if|if
condition|(
name|errno
condition|)
block|{
name|warning
argument_list|(
literal|"error reading directory %s: %s"
argument_list|,
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|closedir
argument_list|(
name|level
operator|->
name|dir
argument_list|)
condition|)
name|warning
argument_list|(
literal|"error closing directory %s: %s"
argument_list|,
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|level
operator|->
name|dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|--
name|iter
operator|->
name|levels_nr
operator|==
literal|0
condition|)
return|return
name|dir_iterator_abort
argument_list|(
name|dir_iterator
argument_list|)
return|;
break|break;
block|}
if|if
condition|(
name|is_dot_or_dotdot
argument_list|(
name|de
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
name|strbuf_addstr
argument_list|(
operator|&
name|iter
operator|->
name|base
operator|.
name|path
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
argument_list|,
operator|&
name|iter
operator|->
name|base
operator|.
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|warning
argument_list|(
literal|"error reading path '%s': %s"
argument_list|,
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * We have to set these each time because 			 * the path strbuf might have been realloc()ed. 			 */
name|iter
operator|->
name|base
operator|.
name|relative_path
operator|=
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
operator|+
name|iter
operator|->
name|levels
index|[
literal|0
index|]
operator|.
name|prefix_len
expr_stmt|;
name|iter
operator|->
name|base
operator|.
name|basename
operator|=
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
operator|+
name|level
operator|->
name|prefix_len
expr_stmt|;
name|level
operator|->
name|dir_state
operator|=
name|DIR_STATE_ITER
expr_stmt|;
return|return
name|ITER_OK
return|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|dir_iterator_abort
name|int
name|dir_iterator_abort
parameter_list|(
name|struct
name|dir_iterator
modifier|*
name|dir_iterator
parameter_list|)
block|{
name|struct
name|dir_iterator_int
modifier|*
name|iter
init|=
operator|(
expr|struct
name|dir_iterator_int
operator|*
operator|)
name|dir_iterator
decl_stmt|;
for|for
control|(
init|;
name|iter
operator|->
name|levels_nr
condition|;
name|iter
operator|->
name|levels_nr
operator|--
control|)
block|{
name|struct
name|dir_iterator_level
modifier|*
name|level
init|=
operator|&
name|iter
operator|->
name|levels
index|[
name|iter
operator|->
name|levels_nr
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|level
operator|->
name|dir
operator|&&
name|closedir
argument_list|(
name|level
operator|->
name|dir
argument_list|)
condition|)
block|{
name|strbuf_setlen
argument_list|(
operator|&
name|iter
operator|->
name|base
operator|.
name|path
argument_list|,
name|level
operator|->
name|prefix_len
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"error closing directory %s: %s"
argument_list|,
name|iter
operator|->
name|base
operator|.
name|path
operator|.
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|iter
operator|->
name|levels
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|iter
operator|->
name|base
operator|.
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iter
argument_list|)
expr_stmt|;
return|return
name|ITER_DONE
return|;
block|}
end_function

begin_function
DECL|function|dir_iterator_begin
name|struct
name|dir_iterator
modifier|*
name|dir_iterator_begin
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|dir_iterator_int
modifier|*
name|iter
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iter
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|dir_iterator
modifier|*
name|dir_iterator
init|=
operator|&
name|iter
operator|->
name|base
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|||
operator|!
operator|*
name|path
condition|)
name|die
argument_list|(
literal|"BUG: empty path passed to dir_iterator_begin()"
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|iter
operator|->
name|base
operator|.
name|path
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|iter
operator|->
name|base
operator|.
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|iter
operator|->
name|levels
argument_list|,
literal|10
argument_list|,
name|iter
operator|->
name|levels_alloc
argument_list|)
expr_stmt|;
name|iter
operator|->
name|levels_nr
operator|=
literal|1
expr_stmt|;
name|iter
operator|->
name|levels
index|[
literal|0
index|]
operator|.
name|initialized
operator|=
literal|0
expr_stmt|;
return|return
name|dir_iterator
return|;
block|}
end_function

end_unit

