begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  LibXDiff by Davide Libenzi ( File Differential Library )  *  Copyright (C) 2003	Davide Libenzi  *  *  This library is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public  *  License as published by the Free Software Foundation; either  *  version 2.1 of the License, or (at your option) any later version.  *  *  This library is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this library; if not, write to the Free Software  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  *  *  Davide Libenzi<davidel@xmailserver.org>  *  */
end_comment

begin_include
include|#
directive|include
file|"xinclude.h"
end_include

begin_define
DECL|macro|XDL_MAX_COST_MIN
define|#
directive|define
name|XDL_MAX_COST_MIN
value|256
end_define

begin_define
DECL|macro|XDL_HEUR_MIN_COST
define|#
directive|define
name|XDL_HEUR_MIN_COST
value|256
end_define

begin_define
DECL|macro|XDL_LINE_MAX
define|#
directive|define
name|XDL_LINE_MAX
value|(long)((1UL<< (CHAR_BIT * sizeof(long) - 1)) - 1)
end_define

begin_define
DECL|macro|XDL_SNAKE_CNT
define|#
directive|define
name|XDL_SNAKE_CNT
value|20
end_define

begin_define
DECL|macro|XDL_K_HEUR
define|#
directive|define
name|XDL_K_HEUR
value|4
end_define

begin_typedef
DECL|struct|s_xdpsplit
typedef|typedef
struct|struct
name|s_xdpsplit
block|{
DECL|member|i1
DECL|member|i2
name|long
name|i1
decl_stmt|,
name|i2
decl_stmt|;
DECL|member|min_lo
DECL|member|min_hi
name|int
name|min_lo
decl_stmt|,
name|min_hi
decl_stmt|;
DECL|typedef|xdpsplit_t
block|}
name|xdpsplit_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|long
name|xdl_split
parameter_list|(
name|unsigned
name|long
specifier|const
modifier|*
name|ha1
parameter_list|,
name|long
name|off1
parameter_list|,
name|long
name|lim1
parameter_list|,
name|unsigned
name|long
specifier|const
modifier|*
name|ha2
parameter_list|,
name|long
name|off2
parameter_list|,
name|long
name|lim2
parameter_list|,
name|long
modifier|*
name|kvdf
parameter_list|,
name|long
modifier|*
name|kvdb
parameter_list|,
name|int
name|need_min
parameter_list|,
name|xdpsplit_t
modifier|*
name|spl
parameter_list|,
name|xdalgoenv_t
modifier|*
name|xenv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|xdchange_t
modifier|*
name|xdl_add_change
parameter_list|(
name|xdchange_t
modifier|*
name|xscr
parameter_list|,
name|long
name|i1
parameter_list|,
name|long
name|i2
parameter_list|,
name|long
name|chg1
parameter_list|,
name|long
name|chg2
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * See "An O(ND) Difference Algorithm and its Variations", by Eugene Myers.  * Basically considers a "box" (off1, off2, lim1, lim2) and scan from both  * the forward diagonal starting from (off1, off2) and the backward diagonal  * starting from (lim1, lim2). If the K values on the same diagonal crosses  * returns the furthest point of reach. We might end up having to expensive  * cases using this algorithm is full, so a little bit of heuristic is needed  * to cut the search and to return a suboptimal point.  */
end_comment

begin_function
DECL|function|xdl_split
specifier|static
name|long
name|xdl_split
parameter_list|(
name|unsigned
name|long
specifier|const
modifier|*
name|ha1
parameter_list|,
name|long
name|off1
parameter_list|,
name|long
name|lim1
parameter_list|,
name|unsigned
name|long
specifier|const
modifier|*
name|ha2
parameter_list|,
name|long
name|off2
parameter_list|,
name|long
name|lim2
parameter_list|,
name|long
modifier|*
name|kvdf
parameter_list|,
name|long
modifier|*
name|kvdb
parameter_list|,
name|int
name|need_min
parameter_list|,
name|xdpsplit_t
modifier|*
name|spl
parameter_list|,
name|xdalgoenv_t
modifier|*
name|xenv
parameter_list|)
block|{
name|long
name|dmin
init|=
name|off1
operator|-
name|lim2
decl_stmt|,
name|dmax
init|=
name|lim1
operator|-
name|off2
decl_stmt|;
name|long
name|fmid
init|=
name|off1
operator|-
name|off2
decl_stmt|,
name|bmid
init|=
name|lim1
operator|-
name|lim2
decl_stmt|;
name|long
name|odd
init|=
operator|(
name|fmid
operator|-
name|bmid
operator|)
operator|&
literal|1
decl_stmt|;
name|long
name|fmin
init|=
name|fmid
decl_stmt|,
name|fmax
init|=
name|fmid
decl_stmt|;
name|long
name|bmin
init|=
name|bmid
decl_stmt|,
name|bmax
init|=
name|bmid
decl_stmt|;
name|long
name|ec
decl_stmt|,
name|d
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|prev1
decl_stmt|,
name|best
decl_stmt|,
name|dd
decl_stmt|,
name|v
decl_stmt|,
name|k
decl_stmt|;
comment|/* 	 * Set initial diagonal values for both forward and backward path. 	 */
name|kvdf
index|[
name|fmid
index|]
operator|=
name|off1
expr_stmt|;
name|kvdb
index|[
name|bmid
index|]
operator|=
name|lim1
expr_stmt|;
for|for
control|(
name|ec
operator|=
literal|1
init|;
condition|;
name|ec
operator|++
control|)
block|{
name|int
name|got_snake
init|=
literal|0
decl_stmt|;
comment|/* 		 * We need to extent the diagonal "domain" by one. If the next 		 * values exits the box boundaries we need to change it in the 		 * opposite direction because (max - min) must be a power of two. 		 * Also we initialize the external K value to -1 so that we can 		 * avoid extra conditions check inside the core loop. 		 */
if|if
condition|(
name|fmin
operator|>
name|dmin
condition|)
name|kvdf
index|[
operator|--
name|fmin
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|++
name|fmin
expr_stmt|;
if|if
condition|(
name|fmax
operator|<
name|dmax
condition|)
name|kvdf
index|[
operator|++
name|fmax
operator|+
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|--
name|fmax
expr_stmt|;
for|for
control|(
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
if|if
condition|(
name|kvdf
index|[
name|d
operator|-
literal|1
index|]
operator|>=
name|kvdf
index|[
name|d
operator|+
literal|1
index|]
condition|)
name|i1
operator|=
name|kvdf
index|[
name|d
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
else|else
name|i1
operator|=
name|kvdf
index|[
name|d
operator|+
literal|1
index|]
expr_stmt|;
name|prev1
operator|=
name|i1
expr_stmt|;
name|i2
operator|=
name|i1
operator|-
name|d
expr_stmt|;
for|for
control|(
init|;
name|i1
operator|<
name|lim1
operator|&&
name|i2
operator|<
name|lim2
operator|&&
name|ha1
index|[
name|i1
index|]
operator|==
name|ha2
index|[
name|i2
index|]
condition|;
name|i1
operator|++
operator|,
name|i2
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i1
operator|-
name|prev1
operator|>
name|xenv
operator|->
name|snake_cnt
condition|)
name|got_snake
operator|=
literal|1
expr_stmt|;
name|kvdf
index|[
name|d
index|]
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|odd
operator|&&
name|bmin
operator|<=
name|d
operator|&&
name|d
operator|<=
name|bmax
operator|&&
name|kvdb
index|[
name|d
index|]
operator|<=
name|i1
condition|)
block|{
name|spl
operator|->
name|i1
operator|=
name|i1
expr_stmt|;
name|spl
operator|->
name|i2
operator|=
name|i2
expr_stmt|;
name|spl
operator|->
name|min_lo
operator|=
name|spl
operator|->
name|min_hi
operator|=
literal|1
expr_stmt|;
return|return
name|ec
return|;
block|}
block|}
comment|/* 		 * We need to extent the diagonal "domain" by one. If the next 		 * values exits the box boundaries we need to change it in the 		 * opposite direction because (max - min) must be a power of two. 		 * Also we initialize the external K value to -1 so that we can 		 * avoid extra conditions check inside the core loop. 		 */
if|if
condition|(
name|bmin
operator|>
name|dmin
condition|)
name|kvdb
index|[
operator|--
name|bmin
operator|-
literal|1
index|]
operator|=
name|XDL_LINE_MAX
expr_stmt|;
else|else
operator|++
name|bmin
expr_stmt|;
if|if
condition|(
name|bmax
operator|<
name|dmax
condition|)
name|kvdb
index|[
operator|++
name|bmax
operator|+
literal|1
index|]
operator|=
name|XDL_LINE_MAX
expr_stmt|;
else|else
operator|--
name|bmax
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
if|if
condition|(
name|kvdb
index|[
name|d
operator|-
literal|1
index|]
operator|<
name|kvdb
index|[
name|d
operator|+
literal|1
index|]
condition|)
name|i1
operator|=
name|kvdb
index|[
name|d
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|i1
operator|=
name|kvdb
index|[
name|d
operator|+
literal|1
index|]
operator|-
literal|1
expr_stmt|;
name|prev1
operator|=
name|i1
expr_stmt|;
name|i2
operator|=
name|i1
operator|-
name|d
expr_stmt|;
for|for
control|(
init|;
name|i1
operator|>
name|off1
operator|&&
name|i2
operator|>
name|off2
operator|&&
name|ha1
index|[
name|i1
operator|-
literal|1
index|]
operator|==
name|ha2
index|[
name|i2
operator|-
literal|1
index|]
condition|;
name|i1
operator|--
operator|,
name|i2
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|prev1
operator|-
name|i1
operator|>
name|xenv
operator|->
name|snake_cnt
condition|)
name|got_snake
operator|=
literal|1
expr_stmt|;
name|kvdb
index|[
name|d
index|]
operator|=
name|i1
expr_stmt|;
if|if
condition|(
operator|!
name|odd
operator|&&
name|fmin
operator|<=
name|d
operator|&&
name|d
operator|<=
name|fmax
operator|&&
name|i1
operator|<=
name|kvdf
index|[
name|d
index|]
condition|)
block|{
name|spl
operator|->
name|i1
operator|=
name|i1
expr_stmt|;
name|spl
operator|->
name|i2
operator|=
name|i2
expr_stmt|;
name|spl
operator|->
name|min_lo
operator|=
name|spl
operator|->
name|min_hi
operator|=
literal|1
expr_stmt|;
return|return
name|ec
return|;
block|}
block|}
if|if
condition|(
name|need_min
condition|)
continue|continue;
comment|/* 		 * If the edit cost is above the heuristic trigger and if 		 * we got a good snake, we sample current diagonals to see 		 * if some of the, have reached an "interesting" path. Our 		 * measure is a function of the distance from the diagonal 		 * corner (i1 + i2) penalized with the distance from the 		 * mid diagonal itself. If this value is above the current 		 * edit cost times a magic factor (XDL_K_HEUR) we consider 		 * it interesting. 		 */
if|if
condition|(
name|got_snake
operator|&&
name|ec
operator|>
name|xenv
operator|->
name|heur_min
condition|)
block|{
for|for
control|(
name|best
operator|=
literal|0
operator|,
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|dd
operator|=
name|d
operator|>
name|fmid
condition|?
name|d
operator|-
name|fmid
else|:
name|fmid
operator|-
name|d
expr_stmt|;
name|i1
operator|=
name|kvdf
index|[
name|d
index|]
expr_stmt|;
name|i2
operator|=
name|i1
operator|-
name|d
expr_stmt|;
name|v
operator|=
operator|(
name|i1
operator|-
name|off1
operator|)
operator|+
operator|(
name|i2
operator|-
name|off2
operator|)
operator|-
name|dd
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|XDL_K_HEUR
operator|*
name|ec
operator|&&
name|v
operator|>
name|best
operator|&&
name|off1
operator|+
name|xenv
operator|->
name|snake_cnt
operator|<=
name|i1
operator|&&
name|i1
operator|<
name|lim1
operator|&&
name|off2
operator|+
name|xenv
operator|->
name|snake_cnt
operator|<=
name|i2
operator|&&
name|i2
operator|<
name|lim2
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|1
init|;
name|ha1
index|[
name|i1
operator|-
name|k
index|]
operator|==
name|ha2
index|[
name|i2
operator|-
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|k
operator|==
name|xenv
operator|->
name|snake_cnt
condition|)
block|{
name|best
operator|=
name|v
expr_stmt|;
name|spl
operator|->
name|i1
operator|=
name|i1
expr_stmt|;
name|spl
operator|->
name|i2
operator|=
name|i2
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|>
literal|0
condition|)
block|{
name|spl
operator|->
name|min_lo
operator|=
literal|1
expr_stmt|;
name|spl
operator|->
name|min_hi
operator|=
literal|0
expr_stmt|;
return|return
name|ec
return|;
block|}
for|for
control|(
name|best
operator|=
literal|0
operator|,
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|dd
operator|=
name|d
operator|>
name|bmid
condition|?
name|d
operator|-
name|bmid
else|:
name|bmid
operator|-
name|d
expr_stmt|;
name|i1
operator|=
name|kvdb
index|[
name|d
index|]
expr_stmt|;
name|i2
operator|=
name|i1
operator|-
name|d
expr_stmt|;
name|v
operator|=
operator|(
name|lim1
operator|-
name|i1
operator|)
operator|+
operator|(
name|lim2
operator|-
name|i2
operator|)
operator|-
name|dd
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|XDL_K_HEUR
operator|*
name|ec
operator|&&
name|v
operator|>
name|best
operator|&&
name|off1
operator|<
name|i1
operator|&&
name|i1
operator|<=
name|lim1
operator|-
name|xenv
operator|->
name|snake_cnt
operator|&&
name|off2
operator|<
name|i2
operator|&&
name|i2
operator|<=
name|lim2
operator|-
name|xenv
operator|->
name|snake_cnt
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|ha1
index|[
name|i1
operator|+
name|k
index|]
operator|==
name|ha2
index|[
name|i2
operator|+
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|k
operator|==
name|xenv
operator|->
name|snake_cnt
operator|-
literal|1
condition|)
block|{
name|best
operator|=
name|v
expr_stmt|;
name|spl
operator|->
name|i1
operator|=
name|i1
expr_stmt|;
name|spl
operator|->
name|i2
operator|=
name|i2
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|>
literal|0
condition|)
block|{
name|spl
operator|->
name|min_lo
operator|=
literal|0
expr_stmt|;
name|spl
operator|->
name|min_hi
operator|=
literal|1
expr_stmt|;
return|return
name|ec
return|;
block|}
block|}
comment|/* 		 * Enough is enough. We spent too much time here and now we collect 		 * the furthest reaching path using the (i1 + i2) measure. 		 */
if|if
condition|(
name|ec
operator|>=
name|xenv
operator|->
name|mxcost
condition|)
block|{
name|long
name|fbest
decl_stmt|,
name|fbest1
decl_stmt|,
name|bbest
decl_stmt|,
name|bbest1
decl_stmt|;
name|fbest
operator|=
name|fbest1
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|i1
operator|=
name|XDL_MIN
argument_list|(
name|kvdf
index|[
name|d
index|]
argument_list|,
name|lim1
argument_list|)
expr_stmt|;
name|i2
operator|=
name|i1
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|lim2
operator|<
name|i2
condition|)
name|i1
operator|=
name|lim2
operator|+
name|d
operator|,
name|i2
operator|=
name|lim2
expr_stmt|;
if|if
condition|(
name|fbest
operator|<
name|i1
operator|+
name|i2
condition|)
block|{
name|fbest
operator|=
name|i1
operator|+
name|i2
expr_stmt|;
name|fbest1
operator|=
name|i1
expr_stmt|;
block|}
block|}
name|bbest
operator|=
name|bbest1
operator|=
name|XDL_LINE_MAX
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|i1
operator|=
name|XDL_MAX
argument_list|(
name|off1
argument_list|,
name|kvdb
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|i2
operator|=
name|i1
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|i2
operator|<
name|off2
condition|)
name|i1
operator|=
name|off2
operator|+
name|d
operator|,
name|i2
operator|=
name|off2
expr_stmt|;
if|if
condition|(
name|i1
operator|+
name|i2
operator|<
name|bbest
condition|)
block|{
name|bbest
operator|=
name|i1
operator|+
name|i2
expr_stmt|;
name|bbest1
operator|=
name|i1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|lim1
operator|+
name|lim2
operator|)
operator|-
name|bbest
operator|<
name|fbest
operator|-
operator|(
name|off1
operator|+
name|off2
operator|)
condition|)
block|{
name|spl
operator|->
name|i1
operator|=
name|fbest1
expr_stmt|;
name|spl
operator|->
name|i2
operator|=
name|fbest
operator|-
name|fbest1
expr_stmt|;
name|spl
operator|->
name|min_lo
operator|=
literal|1
expr_stmt|;
name|spl
operator|->
name|min_hi
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|spl
operator|->
name|i1
operator|=
name|bbest1
expr_stmt|;
name|spl
operator|->
name|i2
operator|=
name|bbest
operator|-
name|bbest1
expr_stmt|;
name|spl
operator|->
name|min_lo
operator|=
literal|0
expr_stmt|;
name|spl
operator|->
name|min_hi
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ec
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Rule: "Divide et Impera". Recursively split the box in sub-boxes by calling  * the box splitting function. Note that the real job (marking changed lines)  * is done in the two boundary reaching checks.  */
end_comment

begin_function
DECL|function|xdl_recs_cmp
name|int
name|xdl_recs_cmp
parameter_list|(
name|diffdata_t
modifier|*
name|dd1
parameter_list|,
name|long
name|off1
parameter_list|,
name|long
name|lim1
parameter_list|,
name|diffdata_t
modifier|*
name|dd2
parameter_list|,
name|long
name|off2
parameter_list|,
name|long
name|lim2
parameter_list|,
name|long
modifier|*
name|kvdf
parameter_list|,
name|long
modifier|*
name|kvdb
parameter_list|,
name|int
name|need_min
parameter_list|,
name|xdalgoenv_t
modifier|*
name|xenv
parameter_list|)
block|{
name|unsigned
name|long
specifier|const
modifier|*
name|ha1
init|=
name|dd1
operator|->
name|ha
decl_stmt|,
modifier|*
name|ha2
init|=
name|dd2
operator|->
name|ha
decl_stmt|;
comment|/* 	 * Shrink the box by walking through each diagonal snake (SW and NE). 	 */
for|for
control|(
init|;
name|off1
operator|<
name|lim1
operator|&&
name|off2
operator|<
name|lim2
operator|&&
name|ha1
index|[
name|off1
index|]
operator|==
name|ha2
index|[
name|off2
index|]
condition|;
name|off1
operator|++
operator|,
name|off2
operator|++
control|)
empty_stmt|;
for|for
control|(
init|;
name|off1
operator|<
name|lim1
operator|&&
name|off2
operator|<
name|lim2
operator|&&
name|ha1
index|[
name|lim1
operator|-
literal|1
index|]
operator|==
name|ha2
index|[
name|lim2
operator|-
literal|1
index|]
condition|;
name|lim1
operator|--
operator|,
name|lim2
operator|--
control|)
empty_stmt|;
comment|/* 	 * If one dimension is empty, then all records on the other one must 	 * be obviously changed. 	 */
if|if
condition|(
name|off1
operator|==
name|lim1
condition|)
block|{
name|char
modifier|*
name|rchg2
init|=
name|dd2
operator|->
name|rchg
decl_stmt|;
name|long
modifier|*
name|rindex2
init|=
name|dd2
operator|->
name|rindex
decl_stmt|;
for|for
control|(
init|;
name|off2
operator|<
name|lim2
condition|;
name|off2
operator|++
control|)
name|rchg2
index|[
name|rindex2
index|[
name|off2
index|]
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|off2
operator|==
name|lim2
condition|)
block|{
name|char
modifier|*
name|rchg1
init|=
name|dd1
operator|->
name|rchg
decl_stmt|;
name|long
modifier|*
name|rindex1
init|=
name|dd1
operator|->
name|rindex
decl_stmt|;
for|for
control|(
init|;
name|off1
operator|<
name|lim1
condition|;
name|off1
operator|++
control|)
name|rchg1
index|[
name|rindex1
index|[
name|off1
index|]
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xdpsplit_t
name|spl
decl_stmt|;
name|spl
operator|.
name|i1
operator|=
name|spl
operator|.
name|i2
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Divide ... 		 */
if|if
condition|(
name|xdl_split
argument_list|(
name|ha1
argument_list|,
name|off1
argument_list|,
name|lim1
argument_list|,
name|ha2
argument_list|,
name|off2
argument_list|,
name|lim2
argument_list|,
name|kvdf
argument_list|,
name|kvdb
argument_list|,
name|need_min
argument_list|,
operator|&
name|spl
argument_list|,
name|xenv
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* 		 * ... et Impera. 		 */
if|if
condition|(
name|xdl_recs_cmp
argument_list|(
name|dd1
argument_list|,
name|off1
argument_list|,
name|spl
operator|.
name|i1
argument_list|,
name|dd2
argument_list|,
name|off2
argument_list|,
name|spl
operator|.
name|i2
argument_list|,
name|kvdf
argument_list|,
name|kvdb
argument_list|,
name|spl
operator|.
name|min_lo
argument_list|,
name|xenv
argument_list|)
operator|<
literal|0
operator|||
name|xdl_recs_cmp
argument_list|(
name|dd1
argument_list|,
name|spl
operator|.
name|i1
argument_list|,
name|lim1
argument_list|,
name|dd2
argument_list|,
name|spl
operator|.
name|i2
argument_list|,
name|lim2
argument_list|,
name|kvdf
argument_list|,
name|kvdb
argument_list|,
name|spl
operator|.
name|min_hi
argument_list|,
name|xenv
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
DECL|function|xdl_do_diff
name|int
name|xdl_do_diff
parameter_list|(
name|mmfile_t
modifier|*
name|mf1
parameter_list|,
name|mmfile_t
modifier|*
name|mf2
parameter_list|,
name|xpparam_t
specifier|const
modifier|*
name|xpp
parameter_list|,
name|xdfenv_t
modifier|*
name|xe
parameter_list|)
block|{
name|long
name|ndiags
decl_stmt|;
name|long
modifier|*
name|kvd
decl_stmt|,
modifier|*
name|kvdf
decl_stmt|,
modifier|*
name|kvdb
decl_stmt|;
name|xdalgoenv_t
name|xenv
decl_stmt|;
name|diffdata_t
name|dd1
decl_stmt|,
name|dd2
decl_stmt|;
if|if
condition|(
name|XDF_DIFF_ALG
argument_list|(
name|xpp
operator|->
name|flags
argument_list|)
operator|==
name|XDF_PATIENCE_DIFF
condition|)
return|return
name|xdl_do_patience_diff
argument_list|(
name|mf1
argument_list|,
name|mf2
argument_list|,
name|xpp
argument_list|,
name|xe
argument_list|)
return|;
if|if
condition|(
name|XDF_DIFF_ALG
argument_list|(
name|xpp
operator|->
name|flags
argument_list|)
operator|==
name|XDF_HISTOGRAM_DIFF
condition|)
return|return
name|xdl_do_histogram_diff
argument_list|(
name|mf1
argument_list|,
name|mf2
argument_list|,
name|xpp
argument_list|,
name|xe
argument_list|)
return|;
if|if
condition|(
name|xdl_prepare_env
argument_list|(
name|mf1
argument_list|,
name|mf2
argument_list|,
name|xpp
argument_list|,
name|xe
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Allocate and setup K vectors to be used by the differential algorithm. 	 * One is to store the forward path and one to store the backward path. 	 */
name|ndiags
operator|=
name|xe
operator|->
name|xdf1
operator|.
name|nreff
operator|+
name|xe
operator|->
name|xdf2
operator|.
name|nreff
operator|+
literal|3
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kvd
operator|=
operator|(
name|long
operator|*
operator|)
name|xdl_malloc
argument_list|(
operator|(
literal|2
operator|*
name|ndiags
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|xdl_free_env
argument_list|(
name|xe
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|kvdf
operator|=
name|kvd
expr_stmt|;
name|kvdb
operator|=
name|kvdf
operator|+
name|ndiags
expr_stmt|;
name|kvdf
operator|+=
name|xe
operator|->
name|xdf2
operator|.
name|nreff
operator|+
literal|1
expr_stmt|;
name|kvdb
operator|+=
name|xe
operator|->
name|xdf2
operator|.
name|nreff
operator|+
literal|1
expr_stmt|;
name|xenv
operator|.
name|mxcost
operator|=
name|xdl_bogosqrt
argument_list|(
name|ndiags
argument_list|)
expr_stmt|;
if|if
condition|(
name|xenv
operator|.
name|mxcost
operator|<
name|XDL_MAX_COST_MIN
condition|)
name|xenv
operator|.
name|mxcost
operator|=
name|XDL_MAX_COST_MIN
expr_stmt|;
name|xenv
operator|.
name|snake_cnt
operator|=
name|XDL_SNAKE_CNT
expr_stmt|;
name|xenv
operator|.
name|heur_min
operator|=
name|XDL_HEUR_MIN_COST
expr_stmt|;
name|dd1
operator|.
name|nrec
operator|=
name|xe
operator|->
name|xdf1
operator|.
name|nreff
expr_stmt|;
name|dd1
operator|.
name|ha
operator|=
name|xe
operator|->
name|xdf1
operator|.
name|ha
expr_stmt|;
name|dd1
operator|.
name|rchg
operator|=
name|xe
operator|->
name|xdf1
operator|.
name|rchg
expr_stmt|;
name|dd1
operator|.
name|rindex
operator|=
name|xe
operator|->
name|xdf1
operator|.
name|rindex
expr_stmt|;
name|dd2
operator|.
name|nrec
operator|=
name|xe
operator|->
name|xdf2
operator|.
name|nreff
expr_stmt|;
name|dd2
operator|.
name|ha
operator|=
name|xe
operator|->
name|xdf2
operator|.
name|ha
expr_stmt|;
name|dd2
operator|.
name|rchg
operator|=
name|xe
operator|->
name|xdf2
operator|.
name|rchg
expr_stmt|;
name|dd2
operator|.
name|rindex
operator|=
name|xe
operator|->
name|xdf2
operator|.
name|rindex
expr_stmt|;
if|if
condition|(
name|xdl_recs_cmp
argument_list|(
operator|&
name|dd1
argument_list|,
literal|0
argument_list|,
name|dd1
operator|.
name|nrec
argument_list|,
operator|&
name|dd2
argument_list|,
literal|0
argument_list|,
name|dd2
operator|.
name|nrec
argument_list|,
name|kvdf
argument_list|,
name|kvdb
argument_list|,
operator|(
name|xpp
operator|->
name|flags
operator|&
name|XDF_NEED_MINIMAL
operator|)
operator|!=
literal|0
argument_list|,
operator|&
name|xenv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|xdl_free
argument_list|(
name|kvd
argument_list|)
expr_stmt|;
name|xdl_free_env
argument_list|(
name|xe
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|xdl_free
argument_list|(
name|kvd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
DECL|function|xdl_add_change
specifier|static
name|xdchange_t
modifier|*
name|xdl_add_change
parameter_list|(
name|xdchange_t
modifier|*
name|xscr
parameter_list|,
name|long
name|i1
parameter_list|,
name|long
name|i2
parameter_list|,
name|long
name|chg1
parameter_list|,
name|long
name|chg2
parameter_list|)
block|{
name|xdchange_t
modifier|*
name|xch
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xch
operator|=
operator|(
name|xdchange_t
operator|*
operator|)
name|xdl_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xdchange_t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|xch
operator|->
name|next
operator|=
name|xscr
expr_stmt|;
name|xch
operator|->
name|i1
operator|=
name|i1
expr_stmt|;
name|xch
operator|->
name|i2
operator|=
name|i2
expr_stmt|;
name|xch
operator|->
name|chg1
operator|=
name|chg1
expr_stmt|;
name|xch
operator|->
name|chg2
operator|=
name|chg2
expr_stmt|;
name|xch
operator|->
name|ignore
operator|=
literal|0
expr_stmt|;
return|return
name|xch
return|;
block|}
end_function

begin_function
DECL|function|is_blank_line
specifier|static
name|int
name|is_blank_line
parameter_list|(
name|xrecord_t
modifier|*
name|rec
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
return|return
name|xdl_blankline
argument_list|(
name|rec
operator|->
name|ptr
argument_list|,
name|rec
operator|->
name|size
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|recs_match
specifier|static
name|int
name|recs_match
parameter_list|(
name|xrecord_t
modifier|*
name|rec1
parameter_list|,
name|xrecord_t
modifier|*
name|rec2
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
return|return
operator|(
name|rec1
operator|->
name|ha
operator|==
name|rec2
operator|->
name|ha
operator|&&
name|xdl_recmatch
argument_list|(
name|rec1
operator|->
name|ptr
argument_list|,
name|rec1
operator|->
name|size
argument_list|,
name|rec2
operator|->
name|ptr
argument_list|,
name|rec2
operator|->
name|size
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If a line is indented more than this, get_indent() just returns this value.  * This avoids having to do absurd amounts of work for data that are not  * human-readable text, and also ensures that the output of get_indent fits within  * an int.  */
end_comment

begin_define
DECL|macro|MAX_INDENT
define|#
directive|define
name|MAX_INDENT
value|200
end_define

begin_comment
comment|/*  * Return the amount of indentation of the specified line, treating TAB as 8  * columns. Return -1 if line is empty or contains only whitespace. Clamp the  * output value at MAX_INDENT.  */
end_comment

begin_function
DECL|function|get_indent
specifier|static
name|int
name|get_indent
parameter_list|(
name|xrecord_t
modifier|*
name|rec
parameter_list|)
block|{
name|long
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|rec
operator|->
name|ptr
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|XDL_ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|ret
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
name|ret
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|ret
operator|+=
literal|8
operator|-
name|ret
operator|%
literal|8
expr_stmt|;
comment|/* ignore other whitespace characters */
if|if
condition|(
name|ret
operator|>=
name|MAX_INDENT
condition|)
return|return
name|MAX_INDENT
return|;
block|}
comment|/* The line contains only whitespace. */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * If more than this number of consecutive blank rows are found, just return this  * value. This avoids requiring O(N^2) work for pathological cases, and also  * ensures that the output of score_split fits in an int.  */
end_comment

begin_define
DECL|macro|MAX_BLANKS
define|#
directive|define
name|MAX_BLANKS
value|20
end_define

begin_comment
comment|/* Characteristics measured about a hypothetical split position. */
end_comment

begin_struct
DECL|struct|split_measurement
struct|struct
name|split_measurement
block|{
comment|/* 	 * Is the split at the end of the file (aside from any blank lines)? 	 */
DECL|member|end_of_file
name|int
name|end_of_file
decl_stmt|;
comment|/* 	 * How much is the line immediately following the split indented (or -1 if 	 * the line is blank): 	 */
DECL|member|indent
name|int
name|indent
decl_stmt|;
comment|/* 	 * How many consecutive lines above the split are blank? 	 */
DECL|member|pre_blank
name|int
name|pre_blank
decl_stmt|;
comment|/* 	 * How much is the nearest non-blank line above the split indented (or -1 	 * if there is no such line)? 	 */
DECL|member|pre_indent
name|int
name|pre_indent
decl_stmt|;
comment|/* 	 * How many lines after the line following the split are blank? 	 */
DECL|member|post_blank
name|int
name|post_blank
decl_stmt|;
comment|/* 	 * How much is the nearest non-blank line after the line following the 	 * split indented (or -1 if there is no such line)? 	 */
DECL|member|post_indent
name|int
name|post_indent
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|split_score
struct|struct
name|split_score
block|{
comment|/* The effective indent of this split (smaller is preferred). */
DECL|member|effective_indent
name|int
name|effective_indent
decl_stmt|;
comment|/* Penalty for this split (smaller is preferred). */
DECL|member|penalty
name|int
name|penalty
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Fill m with information about a hypothetical split of xdf above line split.  */
end_comment

begin_function
DECL|function|measure_split
specifier|static
name|void
name|measure_split
parameter_list|(
specifier|const
name|xdfile_t
modifier|*
name|xdf
parameter_list|,
name|long
name|split
parameter_list|,
name|struct
name|split_measurement
modifier|*
name|m
parameter_list|)
block|{
name|long
name|i
decl_stmt|;
if|if
condition|(
name|split
operator|>=
name|xdf
operator|->
name|nrec
condition|)
block|{
name|m
operator|->
name|end_of_file
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|indent
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|end_of_file
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|indent
operator|=
name|get_indent
argument_list|(
name|xdf
operator|->
name|recs
index|[
name|split
index|]
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|pre_blank
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|pre_indent
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|split
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|m
operator|->
name|pre_indent
operator|=
name|get_indent
argument_list|(
name|xdf
operator|->
name|recs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|pre_indent
operator|!=
operator|-
literal|1
condition|)
break|break;
name|m
operator|->
name|pre_blank
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|pre_blank
operator|==
name|MAX_BLANKS
condition|)
block|{
name|m
operator|->
name|pre_indent
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|m
operator|->
name|post_blank
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|post_indent
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|split
operator|+
literal|1
init|;
name|i
operator|<
name|xdf
operator|->
name|nrec
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|->
name|post_indent
operator|=
name|get_indent
argument_list|(
name|xdf
operator|->
name|recs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|post_indent
operator|!=
operator|-
literal|1
condition|)
break|break;
name|m
operator|->
name|post_blank
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|post_blank
operator|==
name|MAX_BLANKS
condition|)
block|{
name|m
operator|->
name|post_indent
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * The empirically-determined weight factors used by score_split() below.  * Larger values means that the position is a less favorable place to split.  *  * Note that scores are only ever compared against each other, so multiplying  * all of these weight/penalty values by the same factor wouldn't change the  * heuristic's behavior. Still, we need to set that arbitrary scale *somehow*.  * In practice, these numbers are chosen to be large enough that they can be  * adjusted relative to each other with sufficient precision despite using  * integer math.  */
end_comment

begin_comment
comment|/* Penalty if there are no non-blank lines before the split */
end_comment

begin_define
DECL|macro|START_OF_FILE_PENALTY
define|#
directive|define
name|START_OF_FILE_PENALTY
value|1
end_define

begin_comment
comment|/* Penalty if there are no non-blank lines after the split */
end_comment

begin_define
DECL|macro|END_OF_FILE_PENALTY
define|#
directive|define
name|END_OF_FILE_PENALTY
value|21
end_define

begin_comment
comment|/* Multiplier for the number of blank lines around the split */
end_comment

begin_define
DECL|macro|TOTAL_BLANK_WEIGHT
define|#
directive|define
name|TOTAL_BLANK_WEIGHT
value|(-30)
end_define

begin_comment
comment|/* Multiplier for the number of blank lines after the split */
end_comment

begin_define
DECL|macro|POST_BLANK_WEIGHT
define|#
directive|define
name|POST_BLANK_WEIGHT
value|6
end_define

begin_comment
comment|/*  * Penalties applied if the line is indented more than its predecessor  */
end_comment

begin_define
DECL|macro|RELATIVE_INDENT_PENALTY
define|#
directive|define
name|RELATIVE_INDENT_PENALTY
value|(-4)
end_define

begin_define
DECL|macro|RELATIVE_INDENT_WITH_BLANK_PENALTY
define|#
directive|define
name|RELATIVE_INDENT_WITH_BLANK_PENALTY
value|10
end_define

begin_comment
comment|/*  * Penalties applied if the line is indented less than both its predecessor and  * its successor  */
end_comment

begin_define
DECL|macro|RELATIVE_OUTDENT_PENALTY
define|#
directive|define
name|RELATIVE_OUTDENT_PENALTY
value|24
end_define

begin_define
DECL|macro|RELATIVE_OUTDENT_WITH_BLANK_PENALTY
define|#
directive|define
name|RELATIVE_OUTDENT_WITH_BLANK_PENALTY
value|17
end_define

begin_comment
comment|/*  * Penalties applied if the line is indented less than its predecessor but not  * less than its successor  */
end_comment

begin_define
DECL|macro|RELATIVE_DEDENT_PENALTY
define|#
directive|define
name|RELATIVE_DEDENT_PENALTY
value|23
end_define

begin_define
DECL|macro|RELATIVE_DEDENT_WITH_BLANK_PENALTY
define|#
directive|define
name|RELATIVE_DEDENT_WITH_BLANK_PENALTY
value|17
end_define

begin_comment
comment|/*  * We only consider whether the sum of the effective indents for splits are  * less than (-1), equal to (0), or greater than (+1) each other. The resulting  * value is multiplied by the following weight and combined with the penalty to  * determine the better of two scores.  */
end_comment

begin_define
DECL|macro|INDENT_WEIGHT
define|#
directive|define
name|INDENT_WEIGHT
value|60
end_define

begin_comment
comment|/*  * Compute a badness score for the hypothetical split whose measurements are  * stored in m. The weight factors were determined empirically using the tools and  * corpus described in  *  *     https://github.com/mhagger/diff-slider-tools  *  * Also see that project if you want to improve the weights based on, for example,  * a larger or more diverse corpus.  */
end_comment

begin_function
DECL|function|score_add_split
specifier|static
name|void
name|score_add_split
parameter_list|(
specifier|const
name|struct
name|split_measurement
modifier|*
name|m
parameter_list|,
name|struct
name|split_score
modifier|*
name|s
parameter_list|)
block|{
comment|/* 	 * A place to accumulate penalty factors (positive makes this index more 	 * favored): 	 */
name|int
name|post_blank
decl_stmt|,
name|total_blank
decl_stmt|,
name|indent
decl_stmt|,
name|any_blanks
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|pre_indent
operator|==
operator|-
literal|1
operator|&&
name|m
operator|->
name|pre_blank
operator|==
literal|0
condition|)
name|s
operator|->
name|penalty
operator|+=
name|START_OF_FILE_PENALTY
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|end_of_file
condition|)
name|s
operator|->
name|penalty
operator|+=
name|END_OF_FILE_PENALTY
expr_stmt|;
comment|/* 	 * Set post_blank to the number of blank lines following the split, 	 * including the line immediately after the split: 	 */
name|post_blank
operator|=
operator|(
name|m
operator|->
name|indent
operator|==
operator|-
literal|1
operator|)
condition|?
literal|1
operator|+
name|m
operator|->
name|post_blank
else|:
literal|0
expr_stmt|;
name|total_blank
operator|=
name|m
operator|->
name|pre_blank
operator|+
name|post_blank
expr_stmt|;
comment|/* Penalties based on nearby blank lines: */
name|s
operator|->
name|penalty
operator|+=
name|TOTAL_BLANK_WEIGHT
operator|*
name|total_blank
expr_stmt|;
name|s
operator|->
name|penalty
operator|+=
name|POST_BLANK_WEIGHT
operator|*
name|post_blank
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|indent
operator|!=
operator|-
literal|1
condition|)
name|indent
operator|=
name|m
operator|->
name|indent
expr_stmt|;
else|else
name|indent
operator|=
name|m
operator|->
name|post_indent
expr_stmt|;
name|any_blanks
operator|=
operator|(
name|total_blank
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Note that the effective indent is -1 at the end of the file: */
name|s
operator|->
name|effective_indent
operator|+=
name|indent
expr_stmt|;
if|if
condition|(
name|indent
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No additional adjustments needed. */
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|pre_indent
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No additional adjustments needed. */
block|}
elseif|else
if|if
condition|(
name|indent
operator|>
name|m
operator|->
name|pre_indent
condition|)
block|{
comment|/* 		 * The line is indented more than its predecessor. 		 */
name|s
operator|->
name|penalty
operator|+=
name|any_blanks
condition|?
name|RELATIVE_INDENT_WITH_BLANK_PENALTY
else|:
name|RELATIVE_INDENT_PENALTY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indent
operator|==
name|m
operator|->
name|pre_indent
condition|)
block|{
comment|/* 		 * The line has the same indentation level as its predecessor. 		 * No additional adjustments needed. 		 */
block|}
else|else
block|{
comment|/* 		 * The line is indented less than its predecessor. It could be 		 * the block terminator of the previous block, but it could 		 * also be the start of a new block (e.g., an "else" block, or 		 * maybe the previous block didn't have a block terminator). 		 * Try to distinguish those cases based on what comes next: 		 */
if|if
condition|(
name|m
operator|->
name|post_indent
operator|!=
operator|-
literal|1
operator|&&
name|m
operator|->
name|post_indent
operator|>
name|indent
condition|)
block|{
comment|/* 			 * The following line is indented more. So it is likely 			 * that this line is the start of a block. 			 */
name|s
operator|->
name|penalty
operator|+=
name|any_blanks
condition|?
name|RELATIVE_OUTDENT_WITH_BLANK_PENALTY
else|:
name|RELATIVE_OUTDENT_PENALTY
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * That was probably the end of a block. 			 */
name|s
operator|->
name|penalty
operator|+=
name|any_blanks
condition|?
name|RELATIVE_DEDENT_WITH_BLANK_PENALTY
else|:
name|RELATIVE_DEDENT_PENALTY
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|score_cmp
specifier|static
name|int
name|score_cmp
parameter_list|(
name|struct
name|split_score
modifier|*
name|s1
parameter_list|,
name|struct
name|split_score
modifier|*
name|s2
parameter_list|)
block|{
comment|/* -1 if s1.effective_indent< s2->effective_indent, etc. */
name|int
name|cmp_indents
init|=
operator|(
operator|(
name|s1
operator|->
name|effective_indent
operator|>
name|s2
operator|->
name|effective_indent
operator|)
operator|-
operator|(
name|s1
operator|->
name|effective_indent
operator|<
name|s2
operator|->
name|effective_indent
operator|)
operator|)
decl_stmt|;
return|return
name|INDENT_WEIGHT
operator|*
name|cmp_indents
operator|+
operator|(
name|s1
operator|->
name|penalty
operator|-
name|s2
operator|->
name|penalty
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Represent a group of changed lines in an xdfile_t (i.e., a contiguous group  * of lines that was inserted or deleted from the corresponding version of the  * file). We consider there to be such a group at the beginning of the file, at  * the end of the file, and between any two unchanged lines, though most such  * groups will usually be empty.  *  * If the first line in a group is equal to the line following the group, then  * the group can be slid down. Similarly, if the last line in a group is equal  * to the line preceding the group, then the group can be slid up. See  * group_slide_down() and group_slide_up().  *  * Note that loops that are testing for changed lines in xdf->rchg do not need  * index bounding since the array is prepared with a zero at position -1 and N.  */
end_comment

begin_struct
DECL|struct|group
struct|struct
name|group
block|{
comment|/* 	 * The index of the first changed line in the group, or the index of 	 * the unchanged line above which the (empty) group is located. 	 */
DECL|member|start
name|long
name|start
decl_stmt|;
comment|/* 	 * The index of the first unchanged line after the group. For an empty 	 * group, end is equal to start. 	 */
DECL|member|end
name|long
name|end
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Initialize g to point at the first group in xdf.  */
end_comment

begin_function
DECL|function|group_init
specifier|static
name|void
name|group_init
parameter_list|(
name|xdfile_t
modifier|*
name|xdf
parameter_list|,
name|struct
name|group
modifier|*
name|g
parameter_list|)
block|{
name|g
operator|->
name|start
operator|=
name|g
operator|->
name|end
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|xdf
operator|->
name|rchg
index|[
name|g
operator|->
name|end
index|]
condition|)
name|g
operator|->
name|end
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move g to describe the next (possibly empty) group in xdf and return 0. If g  * is already at the end of the file, do nothing and return -1.  */
end_comment

begin_function
DECL|function|group_next
specifier|static
specifier|inline
name|int
name|group_next
parameter_list|(
name|xdfile_t
modifier|*
name|xdf
parameter_list|,
name|struct
name|group
modifier|*
name|g
parameter_list|)
block|{
if|if
condition|(
name|g
operator|->
name|end
operator|==
name|xdf
operator|->
name|nrec
condition|)
return|return
operator|-
literal|1
return|;
name|g
operator|->
name|start
operator|=
name|g
operator|->
name|end
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|g
operator|->
name|end
operator|=
name|g
operator|->
name|start
init|;
name|xdf
operator|->
name|rchg
index|[
name|g
operator|->
name|end
index|]
condition|;
name|g
operator|->
name|end
operator|++
control|)
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Move g to describe the previous (possibly empty) group in xdf and return 0.  * If g is already at the beginning of the file, do nothing and return -1.  */
end_comment

begin_function
DECL|function|group_previous
specifier|static
specifier|inline
name|int
name|group_previous
parameter_list|(
name|xdfile_t
modifier|*
name|xdf
parameter_list|,
name|struct
name|group
modifier|*
name|g
parameter_list|)
block|{
if|if
condition|(
name|g
operator|->
name|start
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|g
operator|->
name|end
operator|=
name|g
operator|->
name|start
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|g
operator|->
name|start
operator|=
name|g
operator|->
name|end
init|;
name|xdf
operator|->
name|rchg
index|[
name|g
operator|->
name|start
operator|-
literal|1
index|]
condition|;
name|g
operator|->
name|start
operator|--
control|)
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * If g can be slid toward the end of the file, do so, and if it bumps into a  * following group, expand this group to include it. Return 0 on success or -1  * if g cannot be slid down.  */
end_comment

begin_function
DECL|function|group_slide_down
specifier|static
name|int
name|group_slide_down
parameter_list|(
name|xdfile_t
modifier|*
name|xdf
parameter_list|,
name|struct
name|group
modifier|*
name|g
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
if|if
condition|(
name|g
operator|->
name|end
operator|<
name|xdf
operator|->
name|nrec
operator|&&
name|recs_match
argument_list|(
name|xdf
operator|->
name|recs
index|[
name|g
operator|->
name|start
index|]
argument_list|,
name|xdf
operator|->
name|recs
index|[
name|g
operator|->
name|end
index|]
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|xdf
operator|->
name|rchg
index|[
name|g
operator|->
name|start
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|xdf
operator|->
name|rchg
index|[
name|g
operator|->
name|end
operator|++
index|]
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|xdf
operator|->
name|rchg
index|[
name|g
operator|->
name|end
index|]
condition|)
name|g
operator|->
name|end
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * If g can be slid toward the beginning of the file, do so, and if it bumps  * into a previous group, expand this group to include it. Return 0 on success  * or -1 if g cannot be slid up.  */
end_comment

begin_function
DECL|function|group_slide_up
specifier|static
name|int
name|group_slide_up
parameter_list|(
name|xdfile_t
modifier|*
name|xdf
parameter_list|,
name|struct
name|group
modifier|*
name|g
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
if|if
condition|(
name|g
operator|->
name|start
operator|>
literal|0
operator|&&
name|recs_match
argument_list|(
name|xdf
operator|->
name|recs
index|[
name|g
operator|->
name|start
operator|-
literal|1
index|]
argument_list|,
name|xdf
operator|->
name|recs
index|[
name|g
operator|->
name|end
operator|-
literal|1
index|]
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|xdf
operator|->
name|rchg
index|[
operator|--
name|g
operator|->
name|start
index|]
operator|=
literal|1
expr_stmt|;
name|xdf
operator|->
name|rchg
index|[
operator|--
name|g
operator|->
name|end
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|xdf
operator|->
name|rchg
index|[
name|g
operator|->
name|start
operator|-
literal|1
index|]
condition|)
name|g
operator|->
name|start
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
DECL|function|xdl_bug
specifier|static
name|void
name|xdl_bug
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BUG: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move back and forward change groups for a consistent and pretty diff output.  * This also helps in finding joinable change groups and reducing the diff  * size.  */
end_comment

begin_function
DECL|function|xdl_change_compact
name|int
name|xdl_change_compact
parameter_list|(
name|xdfile_t
modifier|*
name|xdf
parameter_list|,
name|xdfile_t
modifier|*
name|xdfo
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
name|struct
name|group
name|g
decl_stmt|,
name|go
decl_stmt|;
name|long
name|earliest_end
decl_stmt|,
name|end_matching_other
decl_stmt|;
name|long
name|groupsize
decl_stmt|;
name|unsigned
name|int
name|blank_lines
decl_stmt|;
name|group_init
argument_list|(
name|xdf
argument_list|,
operator|&
name|g
argument_list|)
expr_stmt|;
name|group_init
argument_list|(
name|xdfo
argument_list|,
operator|&
name|go
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If the group is empty in the to-be-compacted file, skip it: */
if|if
condition|(
name|g
operator|.
name|end
operator|==
name|g
operator|.
name|start
condition|)
goto|goto
name|next
goto|;
comment|/* 		 * Now shift the change up and then down as far as possible in 		 * each direction. If it bumps into any other changes, merge them. 		 */
do|do
block|{
name|groupsize
operator|=
name|g
operator|.
name|end
operator|-
name|g
operator|.
name|start
expr_stmt|;
comment|/* 			 * Keep track of the last "end" index that causes this 			 * group to align with a group of changed lines in the 			 * other file. -1 indicates that we haven't found such 			 * a match yet: 			 */
name|end_matching_other
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 			 * Boolean value that records whether there are any blank 			 * lines that could be made to be the last line of this 			 * group. 			 */
name|blank_lines
operator|=
literal|0
expr_stmt|;
comment|/* Shift the group backward as much as possible: */
while|while
condition|(
operator|!
name|group_slide_up
argument_list|(
name|xdf
argument_list|,
operator|&
name|g
argument_list|,
name|flags
argument_list|)
condition|)
if|if
condition|(
name|group_previous
argument_list|(
name|xdfo
argument_list|,
operator|&
name|go
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"group sync broken sliding up"
argument_list|)
expr_stmt|;
comment|/* 			 * This is this highest that this group can be shifted. 			 * Record its end index: 			 */
name|earliest_end
operator|=
name|g
operator|.
name|end
expr_stmt|;
if|if
condition|(
name|go
operator|.
name|end
operator|>
name|go
operator|.
name|start
condition|)
name|end_matching_other
operator|=
name|g
operator|.
name|end
expr_stmt|;
comment|/* Now shift the group forward as far as possible: */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|blank_lines
condition|)
name|blank_lines
operator|=
name|is_blank_line
argument_list|(
name|xdf
operator|->
name|recs
index|[
name|g
operator|.
name|end
operator|-
literal|1
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_slide_down
argument_list|(
name|xdf
argument_list|,
operator|&
name|g
argument_list|,
name|flags
argument_list|)
condition|)
break|break;
if|if
condition|(
name|group_next
argument_list|(
name|xdfo
argument_list|,
operator|&
name|go
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"group sync broken sliding down"
argument_list|)
expr_stmt|;
if|if
condition|(
name|go
operator|.
name|end
operator|>
name|go
operator|.
name|start
condition|)
name|end_matching_other
operator|=
name|g
operator|.
name|end
expr_stmt|;
block|}
block|}
do|while
condition|(
name|groupsize
operator|!=
name|g
operator|.
name|end
operator|-
name|g
operator|.
name|start
condition|)
do|;
comment|/* 		 * If the group can be shifted, then we can possibly use this 		 * freedom to produce a more intuitive diff. 		 * 		 * The group is currently shifted as far down as possible, so the 		 * heuristics below only have to handle upwards shifts. 		 */
if|if
condition|(
name|g
operator|.
name|end
operator|==
name|earliest_end
condition|)
block|{
comment|/* no shifting was possible */
block|}
elseif|else
if|if
condition|(
name|end_matching_other
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Move the possibly merged group of changes back to line 			 * up with the last group of changes from the other file 			 * that it can align with. 			 */
while|while
condition|(
name|go
operator|.
name|end
operator|==
name|go
operator|.
name|start
condition|)
block|{
if|if
condition|(
name|group_slide_up
argument_list|(
name|xdf
argument_list|,
operator|&
name|g
argument_list|,
name|flags
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"match disappeared"
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_previous
argument_list|(
name|xdfo
argument_list|,
operator|&
name|go
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"group sync broken sliding to match"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|XDF_COMPACTION_HEURISTIC
operator|)
operator|&&
name|blank_lines
condition|)
block|{
comment|/* 			 * Compaction heuristic: if it is possible to shift the 			 * group to make its bottom line a blank line, do so. 			 * 			 * As we already shifted the group forward as far as 			 * possible in the earlier loop, we only need to handle 			 * backward shifts, not forward ones. 			 */
while|while
condition|(
operator|!
name|is_blank_line
argument_list|(
name|xdf
operator|->
name|recs
index|[
name|g
operator|.
name|end
operator|-
literal|1
index|]
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|group_slide_up
argument_list|(
name|xdf
argument_list|,
operator|&
name|g
argument_list|,
name|flags
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"blank line disappeared"
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_previous
argument_list|(
name|xdfo
argument_list|,
operator|&
name|go
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"group sync broken sliding to blank line"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|XDF_INDENT_HEURISTIC
condition|)
block|{
comment|/* 			 * Indent heuristic: a group of pure add/delete lines 			 * implies two splits, one between the end of the "before" 			 * context and the start of the group, and another between 			 * the end of the group and the beginning of the "after" 			 * context. Some splits are aesthetically better and some 			 * are worse. We compute a badness "score" for each split, 			 * and add the scores for the two splits to define a 			 * "score" for each position that the group can be shifted 			 * to. Then we pick the shift with the lowest score. 			 */
name|long
name|shift
decl_stmt|,
name|best_shift
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|split_score
name|best_score
decl_stmt|;
for|for
control|(
name|shift
operator|=
name|earliest_end
init|;
name|shift
operator|<=
name|g
operator|.
name|end
condition|;
name|shift
operator|++
control|)
block|{
name|struct
name|split_measurement
name|m
decl_stmt|;
name|struct
name|split_score
name|score
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|measure_split
argument_list|(
name|xdf
argument_list|,
name|shift
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|score_add_split
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|score
argument_list|)
expr_stmt|;
name|measure_split
argument_list|(
name|xdf
argument_list|,
name|shift
operator|-
name|groupsize
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|score_add_split
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_shift
operator|==
operator|-
literal|1
operator|||
name|score_cmp
argument_list|(
operator|&
name|score
argument_list|,
operator|&
name|best_score
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|best_score
operator|.
name|effective_indent
operator|=
name|score
operator|.
name|effective_indent
expr_stmt|;
name|best_score
operator|.
name|penalty
operator|=
name|score
operator|.
name|penalty
expr_stmt|;
name|best_shift
operator|=
name|shift
expr_stmt|;
block|}
block|}
while|while
condition|(
name|g
operator|.
name|end
operator|>
name|best_shift
condition|)
block|{
if|if
condition|(
name|group_slide_up
argument_list|(
name|xdf
argument_list|,
operator|&
name|g
argument_list|,
name|flags
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"best shift unreached"
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_previous
argument_list|(
name|xdfo
argument_list|,
operator|&
name|go
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"group sync broken sliding to blank line"
argument_list|)
expr_stmt|;
block|}
block|}
name|next
label|:
comment|/* Move past the just-processed group: */
if|if
condition|(
name|group_next
argument_list|(
name|xdf
argument_list|,
operator|&
name|g
argument_list|)
condition|)
break|break;
if|if
condition|(
name|group_next
argument_list|(
name|xdfo
argument_list|,
operator|&
name|go
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"group sync broken moving to next group"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|group_next
argument_list|(
name|xdfo
argument_list|,
operator|&
name|go
argument_list|)
condition|)
name|xdl_bug
argument_list|(
literal|"group sync broken at end of file"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
DECL|function|xdl_build_script
name|int
name|xdl_build_script
parameter_list|(
name|xdfenv_t
modifier|*
name|xe
parameter_list|,
name|xdchange_t
modifier|*
modifier|*
name|xscr
parameter_list|)
block|{
name|xdchange_t
modifier|*
name|cscr
init|=
name|NULL
decl_stmt|,
modifier|*
name|xch
decl_stmt|;
name|char
modifier|*
name|rchg1
init|=
name|xe
operator|->
name|xdf1
operator|.
name|rchg
decl_stmt|,
modifier|*
name|rchg2
init|=
name|xe
operator|->
name|xdf2
operator|.
name|rchg
decl_stmt|;
name|long
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|;
comment|/* 	 * Trivial. Collects "groups" of changes and creates an edit script. 	 */
for|for
control|(
name|i1
operator|=
name|xe
operator|->
name|xdf1
operator|.
name|nrec
operator|,
name|i2
operator|=
name|xe
operator|->
name|xdf2
operator|.
name|nrec
init|;
name|i1
operator|>=
literal|0
operator|||
name|i2
operator|>=
literal|0
condition|;
name|i1
operator|--
operator|,
name|i2
operator|--
control|)
if|if
condition|(
name|rchg1
index|[
name|i1
operator|-
literal|1
index|]
operator|||
name|rchg2
index|[
name|i2
operator|-
literal|1
index|]
condition|)
block|{
for|for
control|(
name|l1
operator|=
name|i1
init|;
name|rchg1
index|[
name|i1
operator|-
literal|1
index|]
condition|;
name|i1
operator|--
control|)
empty_stmt|;
for|for
control|(
name|l2
operator|=
name|i2
init|;
name|rchg2
index|[
name|i2
operator|-
literal|1
index|]
condition|;
name|i2
operator|--
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|xch
operator|=
name|xdl_add_change
argument_list|(
name|cscr
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|l1
operator|-
name|i1
argument_list|,
name|l2
operator|-
name|i2
argument_list|)
operator|)
condition|)
block|{
name|xdl_free_script
argument_list|(
name|cscr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cscr
operator|=
name|xch
expr_stmt|;
block|}
operator|*
name|xscr
operator|=
name|cscr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
DECL|function|xdl_free_script
name|void
name|xdl_free_script
parameter_list|(
name|xdchange_t
modifier|*
name|xscr
parameter_list|)
block|{
name|xdchange_t
modifier|*
name|xch
decl_stmt|;
while|while
condition|(
operator|(
name|xch
operator|=
name|xscr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xscr
operator|=
name|xscr
operator|->
name|next
expr_stmt|;
name|xdl_free
argument_list|(
name|xch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|xdl_call_hunk_func
specifier|static
name|int
name|xdl_call_hunk_func
parameter_list|(
name|xdfenv_t
modifier|*
name|xe
parameter_list|,
name|xdchange_t
modifier|*
name|xscr
parameter_list|,
name|xdemitcb_t
modifier|*
name|ecb
parameter_list|,
name|xdemitconf_t
specifier|const
modifier|*
name|xecfg
parameter_list|)
block|{
name|xdchange_t
modifier|*
name|xch
decl_stmt|,
modifier|*
name|xche
decl_stmt|;
for|for
control|(
name|xch
operator|=
name|xscr
init|;
name|xch
condition|;
name|xch
operator|=
name|xche
operator|->
name|next
control|)
block|{
name|xche
operator|=
name|xdl_get_hunk
argument_list|(
operator|&
name|xch
argument_list|,
name|xecfg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xch
condition|)
break|break;
if|if
condition|(
name|xecfg
operator|->
name|hunk_func
argument_list|(
name|xch
operator|->
name|i1
argument_list|,
name|xche
operator|->
name|i1
operator|+
name|xche
operator|->
name|chg1
operator|-
name|xch
operator|->
name|i1
argument_list|,
name|xch
operator|->
name|i2
argument_list|,
name|xche
operator|->
name|i2
operator|+
name|xche
operator|->
name|chg2
operator|-
name|xch
operator|->
name|i2
argument_list|,
name|ecb
operator|->
name|priv
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
DECL|function|xdl_mark_ignorable
specifier|static
name|void
name|xdl_mark_ignorable
parameter_list|(
name|xdchange_t
modifier|*
name|xscr
parameter_list|,
name|xdfenv_t
modifier|*
name|xe
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
name|xdchange_t
modifier|*
name|xch
decl_stmt|;
for|for
control|(
name|xch
operator|=
name|xscr
init|;
name|xch
condition|;
name|xch
operator|=
name|xch
operator|->
name|next
control|)
block|{
name|int
name|ignore
init|=
literal|1
decl_stmt|;
name|xrecord_t
modifier|*
modifier|*
name|rec
decl_stmt|;
name|long
name|i
decl_stmt|;
name|rec
operator|=
operator|&
name|xe
operator|->
name|xdf1
operator|.
name|recs
index|[
name|xch
operator|->
name|i1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xch
operator|->
name|chg1
operator|&&
name|ignore
condition|;
name|i
operator|++
control|)
name|ignore
operator|=
name|xdl_blankline
argument_list|(
name|rec
index|[
name|i
index|]
operator|->
name|ptr
argument_list|,
name|rec
index|[
name|i
index|]
operator|->
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|rec
operator|=
operator|&
name|xe
operator|->
name|xdf2
operator|.
name|recs
index|[
name|xch
operator|->
name|i2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xch
operator|->
name|chg2
operator|&&
name|ignore
condition|;
name|i
operator|++
control|)
name|ignore
operator|=
name|xdl_blankline
argument_list|(
name|rec
index|[
name|i
index|]
operator|->
name|ptr
argument_list|,
name|rec
index|[
name|i
index|]
operator|->
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xch
operator|->
name|ignore
operator|=
name|ignore
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|xdl_diff
name|int
name|xdl_diff
parameter_list|(
name|mmfile_t
modifier|*
name|mf1
parameter_list|,
name|mmfile_t
modifier|*
name|mf2
parameter_list|,
name|xpparam_t
specifier|const
modifier|*
name|xpp
parameter_list|,
name|xdemitconf_t
specifier|const
modifier|*
name|xecfg
parameter_list|,
name|xdemitcb_t
modifier|*
name|ecb
parameter_list|)
block|{
name|xdchange_t
modifier|*
name|xscr
decl_stmt|;
name|xdfenv_t
name|xe
decl_stmt|;
name|emit_func_t
name|ef
init|=
name|xecfg
operator|->
name|hunk_func
condition|?
name|xdl_call_hunk_func
else|:
name|xdl_emit_diff
decl_stmt|;
if|if
condition|(
name|xdl_do_diff
argument_list|(
name|mf1
argument_list|,
name|mf2
argument_list|,
name|xpp
argument_list|,
operator|&
name|xe
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|xdl_change_compact
argument_list|(
operator|&
name|xe
operator|.
name|xdf1
argument_list|,
operator|&
name|xe
operator|.
name|xdf2
argument_list|,
name|xpp
operator|->
name|flags
argument_list|)
operator|<
literal|0
operator|||
name|xdl_change_compact
argument_list|(
operator|&
name|xe
operator|.
name|xdf2
argument_list|,
operator|&
name|xe
operator|.
name|xdf1
argument_list|,
name|xpp
operator|->
name|flags
argument_list|)
operator|<
literal|0
operator|||
name|xdl_build_script
argument_list|(
operator|&
name|xe
argument_list|,
operator|&
name|xscr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|xdl_free_env
argument_list|(
operator|&
name|xe
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|xscr
condition|)
block|{
if|if
condition|(
name|xpp
operator|->
name|flags
operator|&
name|XDF_IGNORE_BLANK_LINES
condition|)
name|xdl_mark_ignorable
argument_list|(
name|xscr
argument_list|,
operator|&
name|xe
argument_list|,
name|xpp
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
argument_list|(
operator|&
name|xe
argument_list|,
name|xscr
argument_list|,
name|ecb
argument_list|,
name|xecfg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|xdl_free_script
argument_list|(
name|xscr
argument_list|)
expr_stmt|;
name|xdl_free_env
argument_list|(
operator|&
name|xe
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|xdl_free_script
argument_list|(
name|xscr
argument_list|)
expr_stmt|;
block|}
name|xdl_free_env
argument_list|(
operator|&
name|xe
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

